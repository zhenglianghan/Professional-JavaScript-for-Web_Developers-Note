# 第四章笔记

### 变量、作用域和内存问题

##### 4.1	基本类型和引用类型的值

1. 给基本类型的值添加属性会返回undefined而不会报错。

2. **ECMAScript中所有参数传递的都是值，不可能通过引用传递参数**。如下例子：

   ```javascript
   function setName(obj) {
   obj.name = 'aaa';
   var obj = new Object(); // 如果是按引用传递的,此处传参进来obj应该被重新引用新的内存单元
   obj.name = 'ccc';
   return obj;
   }
   
   var person = new Object();
   person.name = 'bbb';
   var newPerson = setName(person);
   console.log(person.name + ' | ' + newPerson.name); // aaa | ccc
   ```

   在此例子中传入的obj只是对象的值，里面存有对象的属性的地址，所以obj.name会被改变,而obj是不会被改变的。

3. 如果变量是给定引用类型（**根据它的原型链来识别**）的实例，那么instanceof操作符就会返回true。如下例子:

   ```javascript
   person instanceof Object;  //变量person是Object吗?
   colors instanceof Array;  //变量colors是Array吗?
   pattern instanceof RegExp;  //变量pattern是RegExp吗?
   ```

   所有引用类型的值都是Object的实例。因此检测一个引用类型值和Object构造函数时，instanceof操作符始终返回true。使用instanceof操作符检测基本类型值时始终会返回false。

4. 对正则表达式使用typeof时，Safari5,Chrome7及之前的版本会返回"function"，IE和Firefox会返回"Object"。

5. 基本类型值保存在栈内存中；引用类型值保存在堆内存中。

6. **包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。**

**4.2   执行环境及作用域**

1. 每个执行环境都有一个与之关联的**变量对象**，环境中定义的所有变量和函数都保存在这个对象中。
2. **当代码在一个环境中执行时，会创建变量对象的一个*作用域链*。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。**
3. **标识符解析是沿着作用域链一级一级地搜索标识符的过程。**
4. try-catch语句的catch块和with语句可以**延长作用域链**。这两个语句都会在作用域链的前端添加一个变量对象。**这两个语句并没有使代码进入一个新的执行环境**，语句内部定义的变量会添加到语句外部的变量对象中，可以被外部访问到。
5. **JS中没有块级作用域**，for语句初始化表达式中定义的变量在外部也能访问到。



**4.3   垃圾收集**

1. 垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作
2. JS中最常用的垃圾收集方式是标记清除：给内存中所有变量都加上标记；去掉环境中的变量以及被环境中的变量引用的变量；其它仍然被标记的变量意味着环境中的变量已经无法访问到这些变量了，将被销毁并回收内存
3. 引用计数的方式，会因为循环引用导致变量的引用次数永远不会是0，永远无法回收。
4. 分配给Web浏览器的可用内存数量通常比分配给桌面应用程序的少，防止运行JS的网页耗尽全部的系统内存。因此，我们最好在数据不再有用时将其值设置为null来释放其引用，这个做法叫作**解除引用**